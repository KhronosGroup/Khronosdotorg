<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Khronos&#174; OpenCL Working Group">
<title>The C++ for OpenCL 1.0 and 2021 Programming Language Documentation</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fff; color: #222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: black; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #0068b0; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #333; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: Noto, sans-serif; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Noto, sans-serif; font-weight: normal; font-style: normal; color: black; text-rendering: optimizeLegibility; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #4d4d4d; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #264357; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; list-style-position: outside; font-family: Noto, sans-serif; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #ddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 0.75em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #365E7A; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #365E7A; }

blockquote, blockquote p { line-height: 1.6; color: #333; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #d8d8ce; }
table thead, table tfoot { background: #eee; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #6d6e71; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f8; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.4; }

body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }

a:hover, a:focus { text-decoration: underline; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 0; background-color: transparent; -webkit-border-radius: 0; border-radius: 0; line-height: inherit; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.6; color: #264357; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: #333333; }

kbd { font-family: Consolas, "Liberation Mono", Courier, monospace; display: inline-block; color: black; font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menuref { color: #000; }

.menuseq b:not(.caret), .menuref { font-weight: inherit; }

.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.25em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.5em; padding-right: 1.5em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: black; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #365E7A; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #333; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #333; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: black; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0 solid #ddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: Noto, sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: black; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #fff; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #ddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: none; padding: 1.25em; }

#footer-text { color: black; line-height: 1.44; }

#content { margin-bottom: 0.625em; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }

.sect1 + .sect1 { border-top: 0 solid #ddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: black; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: black; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: black; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: Noto, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddd; color: #365E7A; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: black; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #eee; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px hidden #666; -webkit-border-radius: 0; border-radius: 0; word-wrap: break-word; padding: 1.25em 1.5625em 1.125em 1.5625em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #eee; background-color: #264357; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1.25em 1.5625em 1.125em 1.5625em; -webkit-border-radius: 0; border-radius: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.6; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 0.75em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #333; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: black; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #365E7A; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 0.75em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #333; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #365E7A; }

.quoteblock.abstract { margin: 0 0 0.75em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #d8d8ce; }

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }

table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }

table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }

table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.4; background: #eee; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.375em; }

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }

ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }

ul.unstyled, ol.unstyled { margin-left: 0; }

ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.8em; position: relative; bottom: 0.125em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.375em -0.75em; }

ul.inline > li { margin-left: 0.75em; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 0.75em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #29475c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { border-bottom: 1px solid #ddd; }

.sect1 { padding-bottom: 0; }

#toctitle { color: #00406F; font-weight: normal; margin-top: 1.5em; }

.sidebarblock { border-color: #aaa; }

code { -webkit-border-radius: 4px; border-radius: 4px; }

p.tableblock.header { color: #6d6e71; }

.literalblock pre, .listingblock pre { background: #eee; }

/* From https://github.com/KhronosGroup/Vulkan-Docs/pull/901 */
a code { color: inherit; }

/* From https://github.com/KhronosGroup/Vulkan-Docs/pull/1157 */
/* Make VUID anchor handles*/
li > p > a[id^="VUID-"] { visibility: hidden; position: absolute; z-index: 1001; width: 2.2ex; margin-left: -2.2ex; display: block; text-decoration: none !important; text-align: center; font-weight: normal; }

li > p > a[id^="VUID-"]:before { content: "\00A7"; font-size: 1em; display: block; padding-top: 0em; background: #fff; }

li > p:hover > a[id^="VUID-"], li > p > a[id^="VUID-"]:hover { visibility: visible; }

li > p > a[id^="VUID-"].link { color: black; text-decoration: none; }

/* TODO: not quite sure what these two do */
li > p > a[id^="VUID-"].link:hover { color: black; }

.vuid { color: #4d4d4d; font-family: monospace; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../katex/katex.min.css">
<script src="../katex/katex.min.js"></script>
<script src="../katex/contrib/auto-render.min.js"></script>
    <!-- Use KaTeX to render math once document is loaded, see
         https://github.com/Khan/KaTeX/tree/master/contrib/auto-render -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    { left: "$$", right: "$$", display: true},
                    { left: "\\[", right: "\\]", display: true},
                    { left: "$", right: "$", display: false},
                    { left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    });
</script></head>
<body class="book toc2 toc-left">
<div id="header" style="max-width: 100;">
<h1>The C++ for OpenCL 1.0 and 2021 Programming Language Documentation</h1>
<div class="details">
<span id="author" class="author">Khronos<sup>&#174;</sup> OpenCL Working Group</span><br>
<span id="revnumber">version DocRev2021.12,</span>
<span id="revdate">Fri, 02 Dec 2022 11:53:51 +0000</span>
<br><span id="revremark">from git branch: main commit: a897dfb2e238e7e0b623dd9b774e67a922fe52dc tag: v3.0.12-4-ga897dfb</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#intro">1. Introduction</a></li>
<li><a href="#_version_differences">2. Version differences</a></li>
<li><a href="#_the_c_for_opencl_programming_language">3. The C++ for OpenCL Programming Language</a>
<ul class="sectlevel2">
<li><a href="#diff2cxx">3.1. Difference to C++</a>
<ul class="sectlevel3">
<li><a href="#_restrictions_to_c_features">3.1.1. Restrictions to C++ features</a></li>
</ul>
</li>
<li><a href="#diff2openclc">3.2. Difference to OpenCL C</a>
<ul class="sectlevel3">
<li><a href="#_c_related_differences">3.2.1. C++ related differences</a>
<ul class="sectlevel4">
<li><a href="#_implicit_conversions">3.2.1.1. Implicit conversions</a></li>
<li><a href="#null_literal">3.2.1.2. Null pointer constant</a></li>
<li><a href="#_use_of_restrict">3.2.1.3. Use of restrict</a></li>
<li><a href="#_limitations_of_goto_statements">3.2.1.4. Limitations of goto statements</a></li>
<li><a href="#_ternary_selection_operator">3.2.1.5. Ternary selection operator</a></li>
</ul>
</li>
<li><a href="#_opencl_specific_difference">3.2.2. OpenCL specific difference</a>
<ul class="sectlevel4">
<li><a href="#_variadic_macros">3.2.2.1. Variadic macros</a></li>
<li><a href="#_predefined_macros">3.2.2.2. Predefined macros</a></li>
<li><a href="#_atomic_operations">3.2.2.3. Atomic operations</a></li>
<li><a href="#_use_of_blocks">3.2.2.4. Use of Blocks</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#address_space">3.3. Address spaces</a>
<ul class="sectlevel3">
<li><a href="#address_space_casts">3.3.1. Casts</a></li>
<li><a href="#references">3.3.2. References</a></li>
<li><a href="#addrspace-deduction">3.3.3. Address space inference</a></li>
<li><a href="#addrspace-member-function-qualifiers">3.3.4. Member function qualifier</a></li>
<li><a href="#_lambda_function">3.3.5. Lambda function</a></li>
<li><a href="#_implicit_special_members">3.3.6. Implicit special members</a></li>
<li><a href="#_builtin_operators">3.3.7. Builtin operators</a></li>
<li><a href="#_templates">3.3.8. Templates</a></li>
<li><a href="#_temporary_materialization">3.3.9. Temporary materialization</a></li>
<li><a href="#_construction_initialization_and_destruction">3.3.10. Construction, initialization and destruction</a></li>
<li><a href="#_nested_pointers">3.3.11. Nested pointers</a></li>
<li><a href="#remove-addrspace">3.3.12. Address space removal type trait</a></li>
</ul>
</li>
<li><a href="#cxxcasts">3.4. C++ casts</a>
<ul class="sectlevel3">
<li><a href="#_vectors_and_scalars">3.4.1. Vectors and scalars</a></li>
<li><a href="#_opencl_types">3.4.2. OpenCL types</a></li>
</ul>
</li>
<li><a href="#kernel_function">3.5. Kernel functions</a></li>
</ul>
</li>
<li><a href="#_normative_references">4. Normative References</a></li>
</ul>
</div>
</div>
<div id="content" style="max-width: 100;">
<div id="preamble">
<div class="sectionbody">
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>Copyright 2019-2022 The Khronos Group.</p>
</div>
<div class="paragraph">
<p>Khronos licenses this file to you under the Creative Commons Attribution 4.0
International (CC BY 4.0) License (the "License"); you may not use this file
except in compliance with the License.  You may obtain a copy of the License
at <a href="https://creativecommons.org/licenses/by/4.0/" class="bare">https://creativecommons.org/licenses/by/4.0/</a></p>
</div>
<div class="paragraph">
<p>Unless required by applicable law or agreed to in writing, material distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. If all or a portion of this
material is re-used, notice substantially similar to the following must be included:</p>
</div>
<div class="paragraph">
<p>This documentation includes material developed at The Khronos Group
(<a href="http://www.khronos.org/" class="bare">http://www.khronos.org/</a>). Khronos supplied such material on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, under
the terms of the Creative Commons Attribution 4.0 International (CC BY 4.0)
License (the "License"), available at <a href="https://creativecommons.org/licenses/by/4.0/" class="bare">https://creativecommons.org/licenses/by/4.0/</a>.
All use of such material is governed by the term of the License. Khronos bears
no responsibility whatsoever for additions or modifications to its material.</p>
</div>
<div class="paragraph">
<p>Khronos is a registered trademark, and OpenCL is a trademark of Apple Inc.
and used under license by Khronos. All other product names, trademarks, and/or
company names are used solely for identification and belong to their respective
owners.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="intro"><a class="anchor" href="#intro"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This language is built on top of OpenCL C 3.0 unified and C++17 enabling
most of regular C++ features in OpenCL kernel code. Most functionality
from C++ and OpenCL C is inherited. Since both OpenCL C and C++ are
derived from C and moreover C++ is almost fully backward compatible with C,
the main design principle of C++ for OpenCL is to reapply existing OpenCL
concepts to C++. Therefore, it is important to refer to
<a href="#opencl-spec">The OpenCL Specification, Version 3.0</a> <code>section
3.2</code> and <code>section 3.3</code> detailing fundamental differences of OpenCL execution
and memory models from the conventional C and C++ view.</p>
</div>
<div class="paragraph">
<p>This document describes the programming language in detail. It is not
structured as a standalone document, but rather as an addition to OpenCL C
3.0 unified specification defined in <a href="#openclc-spec">The OpenCL C Specification,
Version 3.0</a> and C++17 defined in <a href="#cpp17-spec">The C++17 Specification</a>.
Where necessary this document refers to the specifications of those languages
accordingly. A full understanding of C++ for OpenCL requires familiarity with
the specifications or other documentation of both languages that C++ for OpenCL
is built upon.</p>
</div>
<div class="paragraph">
<p>The description of C++ for OpenCL starts from highlighting <a href="#diff2openclc"><em>the differences to OpenCL C</em></a> and <a href="#diff2cxx"><em>the differences to C++</em></a>.</p>
</div>
<div class="paragraph">
<p>The majority of content covers the behavior that is not documented in
the <code>OpenCL C 3.0 s6</code> and C++17 specifications. This is mainly
related to interactions between OpenCL and C++ language features.</p>
</div>
<div class="paragraph">
<p>This document describes C++ for OpenCL language</p>
</div>
<div class="ulist">
<ul>
<li>
<p>version 1.0 that is backward compatible with OpenCL 2.0; and</p>
</li>
<li>
<p>version 2021 that is backward compatible with OpenCL 3.0.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>C++ for OpenCL 2021 is described in this document as a provisional language
version. While no large changes are envisioned in the future, some minor
aspects might not remain identical in its final release.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_version_differences"><a class="anchor" href="#_version_differences"></a>2. Version differences</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main difference between C++ for OpenCL version 1.0 and version 2021
comes from the difference between OpenCL 2.0 and OpenCL 3.0 with which they
are respectively compatible. Support for some features of C++ for OpenCL 1.0
has become optional as described in <code>OpenCL 3.0 s6.2.1</code>. Predefined feature
macros from OpenCL C 3.0 can be used to detect which optional features are present.</p>
</div>
<div class="paragraph">
<p>This impacts some C++ specific semantics mainly due to optionality of the
generic address space (i.e. <code>__opencl_c_generic_address_space</code> feature) or
program scope variables (i.e. <code>__opencl_c_program_scope_global_variables</code>
feature).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_c_for_opencl_programming_language"><a class="anchor" href="#_the_c_for_opencl_programming_language"></a>3. The C++ for OpenCL Programming Language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This programming language inherits features from <code>OpenCL C 3.0 s6</code> as well
as C++17. Detailed aspects of OpenCL and C++ are not described in this
document as they can be found in their official specifications.</p>
</div>
<div class="paragraph">
<p>This section documents various language features of C++ for OpenCL that are
not covered in neither OpenCL nor C++ specifications, in particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>any behavior that deviates from C++17;</p>
</li>
<li>
<p>any behavior that deviates from OpenCL C 2.0 or 3.0;</p>
</li>
<li>
<p>any behavior that is not governed by OpenCL C and C++.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All language extensions to OpenCL C are applicable to C++ for OpenCL.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Extensions to OpenCL C 2.0 or earlier versions apply to C++ for OpenCL
version 1.0.</p>
</li>
<li>
<p>Extensions to OpenCL C 3.0 or earlier versions except for OpenCL C 2.0,
apply to C++ for OpenCL 2021.</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
<div class="sect2">
<h3 id="diff2cxx"><a class="anchor" href="#diff2cxx"></a>3.1. Difference to C++</h3>
<div class="paragraph">
<p>C++ for OpenCL supports the majority of standard C++17 features,
however, there are some differences that are documented in this section.</p>
</div>
<div class="sect3">
<h4 id="_restrictions_to_c_features"><a class="anchor" href="#_restrictions_to_c_features"></a>3.1.1. Restrictions to C++ features</h4>
<div class="paragraph">
<p>The following C++ language features are not supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Virtual functions (C++17 <code>[class.virtual]</code>);</p>
</li>
<li>
<p>References to functions (C++17 <code>[class.mfct]</code>);</p>
</li>
<li>
<p>Pointers to class member functions (in addition to the regular non-member
functions that are already restricted in OpenCL C);</p>
</li>
<li>
<p>Exceptions (C++17 <code>[except]</code>);</p>
</li>
<li>
<p><code>dynamic_cast</code> operator (C++17 <code>[expr.dynamic.cast]</code>);</p>
</li>
<li>
<p>Non-placement <code>new</code>/<code>delete</code> operators (C++17
<code>[expr.new]</code>/<code>[expr.delete]</code>);</p>
</li>
<li>
<p><code>thread_local</code> storage class specifier (C++17 <code>[basic.stc.thread]</code>);</p>
</li>
<li>
<p>Standard C++ libraries (C++17 <code>[library]</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Simultaneous initialization of static local objects performed by
different work-items is not guaranteed to be free from race-conditions.
Whether an implementation provides such a guarantee is indicated by the
presence of the <code>__cpp_threadsafe_static_init</code> feature test
macro<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>The list above only contains extra restrictions that are not detailed in OpenCL
C specification. As OpenCL restricts a number of C features, the same restrictions
are inherited by C++ for OpenCL. The detailed list of C feature restrictions
is provided in <code>OpenCL C 3.0 s6.11</code>.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="diff2openclc"><a class="anchor" href="#diff2openclc"></a>3.2. Difference to OpenCL C</h3>
<div class="paragraph">
<p>C++ for OpenCL provides backwards compatibility with OpenCL C
for the majority of features. However, there are a number of
exceptions that are described in this section. Some of them come
from the nature of C++ but others are due to improvements in OpenCL
features. Most of such improvements do not invalidate code written in
OpenCL C, but simply provide extra functionality.</p>
</div>
<div class="sect3">
<h4 id="_c_related_differences"><a class="anchor" href="#_c_related_differences"></a>3.2.1. C++ related differences</h4>
<div class="paragraph">
<p>C++ for OpenCL is a different language to OpenCL C and it is derived
from C++ inheriting C++'s fundamental design principles. Hence
C++ for OpenCL deviates from OpenCL C in the same areas where
C++ deviates from C. This results in a more helpful language for
developers and facilitates improvements in compilation tools without
substantially increasing their complexity.</p>
</div>
<div class="sect4">
<h5 id="_implicit_conversions"><a class="anchor" href="#_implicit_conversions"></a>3.2.1.1. Implicit conversions</h5>
<div class="paragraph">
<p>C++ is much stricter about conversions between types,
especially those that are performed implicitly by the compiler.
For example it is not possible to convert a <code>const</code> object
to non-<code>const</code> implicitly. For details please refer to C++17 <code>[conv]</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">void foo(){
  const int *ptrconst;
  int *ptr = ptrconst; // invalid initialization discards const qualifier.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same applies to narrowing conversions in
initialization lists (C++17 <code>[dcl.init.list]</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">struct mytype {
 int i;
};
void foo(uint par){
  mytype var = {
    .i = par // narrowing from uint to int is disallowed.
  };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some compilers allow silencing this error using a flag
(e.g. in Clang <code>-Wno-error=c++11-narrowing</code> can be used).</p>
</div>
<div class="paragraph">
<p>Among other common conversions that will not be compiled in C++
mode there are pointer to integer or integer to pointer
type conversions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">void foo(){
  int *ptr;
  int i = ptr; // incompatible pointer to integer conversion.
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="null_literal"><a class="anchor" href="#null_literal"></a>3.2.1.2. Null pointer constant</h5>
<div class="paragraph">
<p>In C and OpenCL C the null pointer constant is defined using other
language features as it is not represented explicitly i.e.
commonly it is defined as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">#define NULL ((void*)0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In C++17 there is an explicit builtin pointer literal <code>nullptr</code> that should
be used instead (C++17 <code>[lex.nullptr]</code>).</p>
</div>
<div class="paragraph">
<p><code>NULL</code> macro definition in C++ for OpenCL follows C++17
<code>[support.types.nullptr]</code> where it is an implementation defined macro and it
is not guaranteed to be the same as in OpenCL C. Reusing the definition of
<code>NULL</code> from OpenCL C does not guarantee that any code with NULL is legal in
C++ for OpenCL even if it is legal in OpenCL C.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">#define NULL ((void*)0)
void foo(){
 int *ptr = NULL; // invalid initialization of int* with void*.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To improve code portability and compatibility, implementations are
encouraged to define <code>NULL</code> as an alias to pointer literal <code>nullptr</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_use_of_restrict"><a class="anchor" href="#_use_of_restrict"></a>3.2.1.3. Use of restrict</h5>
<div class="paragraph">
<p>C++17 does not support <code>restrict</code> and therefore C++ for OpenCL
can not support it either. Some compilers might provide extensions
with some functionality of <code>restrict</code> in C++, e.g. <code>__restrict</code>
in Clang.</p>
</div>
<div class="paragraph">
<p>This feature only affects optimizations and the source
code can be modified by removing it. As a workaround to avoid manual
modifications, macro substitutions can be used to either remove the
keyword during the preprocessing by defining <code>restrict</code> as an empty
macro or mapping it to another similar compiler features, e.g.
<code>__restrict</code> in Clang. This can be done in headers or using <code>-D</code>
compilation flag.</p>
</div>
</div>
<div class="sect4">
<h5 id="_limitations_of_goto_statements"><a class="anchor" href="#_limitations_of_goto_statements"></a>3.2.1.4. Limitations of goto statements</h5>
<div class="paragraph">
<p>C++ is more restrictive with respect to entering the scope of
variables than C. It is not possible to jump forward over a variable
declaration statement apart from some exceptions detailed in C++17
<code>[stmt.dcl]</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">if (cond)
  goto label;
int n = foo();
label:  // invalid: jumping forward over declaration of n.
   // ...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ternary_selection_operator"><a class="anchor" href="#_ternary_selection_operator"></a>3.2.1.5. Ternary selection operator</h5>
<div class="paragraph">
<p>The ternary selection operator (<code>?:</code>) inherits its behaviour from both
C++ and OpenCL C. It operates on three expressions
<code>(exp1 ? exp2 : exp3)</code>. If all three expressions are scalar values,
the C++17 rules for ternary operator are followed. If the result is
a vector value, then this is equivalent to calling
<code>select(exp3, exp2, exp1)</code> as described in <code>OpenCL C 3.0 s6.15.6</code>.
The rules from OpenCL C impose limitation that <code>exp1</code> cannot be a
vector of float values. However, <code>exp1</code> can be evaluated to a scalar
float as it is contextually convertible to bool in C++.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_opencl_specific_difference"><a class="anchor" href="#_opencl_specific_difference"></a>3.2.2. OpenCL specific difference</h4>
<div class="paragraph">
<p>This section describes where C++ for OpenCL differs from OpenCL C
in OpenCL specific behavior.</p>
</div>
<div class="sect4">
<h5 id="_variadic_macros"><a class="anchor" href="#_variadic_macros"></a>3.2.2.1. Variadic macros</h5>
<div class="paragraph">
<p>C++ for OpenCL eliminates the restriction on variadic macros from
<code>OpenCL C 3.0 s6.11.f</code>.
Variadic macros can be used normally as per C++17 <code>[cpp.replace]</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_predefined_macros"><a class="anchor" href="#_predefined_macros"></a>3.2.2.2. Predefined macros</h5>
<div class="paragraph">
<p>The macro <code>__OPENCL_C_VERSION__</code> described in <code>OpenCL C 3.0 s6.12</code>,
is not defined.</p>
</div>
<div class="paragraph">
<p>The following new predefined macros are added in C++ for OpenCL:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>__OPENCL_CPP_VERSION__</code> set to integer value reflecting the C++
for OpenCL version the translation unit is compiled for. The value
<code>100</code> corresponds to the language version 1.0 and <code>202100</code> corresponds
to the version 2021.</p>
</li>
<li>
<p><code>__CL_CPP_VERSION_1_0__</code> set to <code>100</code> and can be used for
convenience instead of a literal.</p>
</li>
<li>
<p><code>__CL_CPP_VERSION_2021__</code> set to <code>202100</code> and can be used for
convenience instead of a literal.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_atomic_operations"><a class="anchor" href="#_atomic_operations"></a>3.2.2.3. Atomic operations</h5>
<div class="paragraph">
<p>C++ for OpenCL relaxes restriction from <code>OpenCL C 3.0 s6.15.12</code> to
atomic types allowing them to be used by builtin operators, and not
only by builtin functions. This relaxation does not apply to
C++ for OpenCL version 2021 if the sequential consistency memory model
(i.e. <code>__opencl_c_atomic_order_seq_cst</code> feature) is not supported.</p>
</div>
<div class="paragraph">
<p>Operators on atomic types behave as described in C++17
sections <code>[atomics.types.int]</code> <code>[atomics.types.pointer]</code>
<code>[atomics.types.float]</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">// Assumes support of sequential consistency memory model.
atomic_int acnt;
acnt++; // equivalent to atomic_fetch_add(&amp;acnt, 1);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_use_of_blocks"><a class="anchor" href="#_use_of_blocks"></a>3.2.2.4. Use of Blocks</h5>
<div class="paragraph">
<p>Blocks that are defined in <code>OpenCL C 3.0 s6.14</code> are not supported
and their use might be replaced by lambdas (C++17 <code>[expr.prim.lambda]</code>)
in future versions.</p>
</div>
<div class="paragraph">
<p>The above implies that builtin functions using blocks, such as <code>enqueue_kernel</code>,
are not supported in C++ for OpenCL.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="address_space"><a class="anchor" href="#address_space"></a>3.3. Address spaces</h3>
<div class="paragraph">
<p>C++ for OpenCL inherits address space behavior from <code>OpenCL C 3.0 s6.7</code>.</p>
</div>
<div class="paragraph">
<p>This section only documents behavior related to C++ features. For example,
conversion rules are extended from the qualification conversion in C++17
<code>[conv.qual]</code> but the compatibility is determined using notation of sets and
overlapping of address spaces from <code>section 5.1.3</code> of <a href="#embedded-c-spec">The Embedded C Specification</a>. For OpenCL kernel languages there are two
main semantics depending on whether generic address space (<code>OpenCL C 3.0 s6.7.5</code>)
is supported on not. The generic address space is always supported for</p>
</div>
<div class="ulist">
<ul>
<li>
<p>C++ for OpenCL 1.0;</p>
</li>
<li>
<p>C++ for OpenCL 2021 with the presence of <code>__opencl_c_generic_address_space</code>
feature as explained in <code>OpenCL C 3.0 s6.2.1</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If generic address space is not supported, qualification conversions with pointer
type where address spaces differ are not allowed. If generic address space is
supported, implicit conversions are allowed from a named address space (except for
<code>__constant</code>) to generic address space. The reverse conversion is only allowed
explicitly. The <code>__constant</code> address space does not overlap with any other,
therefore, no valid conversion between <code>__constant</code> and any other address space
exists. This is aligned with rules from <code>OpenCL C 3.0 s6.7.9</code> and this logic
regulates semantics described in this section.</p>
</div>
<div class="sect3">
<h4 id="address_space_casts"><a class="anchor" href="#address_space_casts"></a>3.3.1. Casts</h4>
<div class="paragraph">
<p>C-style casts follow rules of <code>OpenCL C 3.0 s6.7.9</code>. Conversions of
references and pointers to the generic address space can be done by any C++ cast
operator (as an implicit conversion); converting from generic to named address
space can only be done using the dedicated <code>addrspace_cast</code> operator. The
<code>addrspace_cast</code> operator can only convert between address spaces for pointers and
references and no other conversions are allowed to occur. Note that conversions
between <code>__constant</code> and any other other address space are disallowed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">// Example assumes generic address space support.
int * genptr; // points to generic address space.

// generic -&gt; named address space conversions.
__private float * ptrfloat = reinterpret_cast&lt;__private float*&gt;(genptr); // illegal.
__private float * ptrfloat = addrspace_cast&lt;__private float*&gt;(genptr); // illegal.
__private int * ptr = addrspace_cast&lt;__private int*&gt;(genptr); // legal.

// named -&gt; generic address space conversion.
float * genptrfloat = reinterpret_cast&lt;float*&gt;(ptr); // legal.

// disjoint address space conversion.
__constant int * constptr = addrspace_cast&lt;__constant int*&gt;(genptr); // illegal.</code></pre>
</div>
</div>
<div class="paragraph">
<p>If generic address space is not supported, any conversion of references/pointers
pointing to different address spaces is illegal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">// Example without generic address space support.
int * privptr; // points to private address space.

// The same address space conversions.
__private float * ptrfloat = reinterpret_cast&lt;__private float*&gt;(privptr); // legal.
__private float * ptrfloat = addrspace_cast&lt;__private float*&gt;(privptr); // illegal.
__private int * ptr = addrspace_cast&lt;__private int*&gt;(privptr); // legal, no op.
float * privptrfloat = reinterpret_cast&lt;float*&gt;(ptr); // legal.

// disjoint address space conversion.
__constant int * constptr = addrspace_cast&lt;__constant int*&gt;(privptr); // illegal.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="references"><a class="anchor" href="#references"></a>3.3.2. References</h4>
<div class="paragraph">
<p>Reference types can be qualified with an address space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">__private int &amp; ref = ...; // references int in __private address space.</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default references refer to generic address space objects if generic
address space is supported or private address space otherwise, except
for dependent types that are not template specializations (see
<a href="#addrspace-deduction"><em>Address space inference</em></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">int &amp; ref = ...; // references int in generic address space if it is
                 // supported otherwise in __private address space.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Address space compatibility checks are performed when references are
bound to values. The logic follows the rules from address space pointer
conversion (<code>OpenCL C 3.0 s6.7.9</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">void f(float &amp;ref, __global float &amp;globref) {
  const int&amp; tmp = ref; // legal - reference to generic/__private address space object
                        // can bind to a temporary object created in __private
                        // address space.

  __global const int&amp; globtmp = globref; // error: reference to global address space
                                         // object cannot bind to a temporary object
                                         // created in __private  address space.
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="addrspace-deduction"><a class="anchor" href="#addrspace-deduction"></a>3.3.3. Address space inference</h4>
<div class="paragraph">
<p>This section details what happens if address spaces for types are not
provided in the source code explicitly. Most of the logic for address space
inference (i.e. default address space) follows rules from <code>OpenCL C 3.0 s6.7.8</code>.</p>
</div>
<div class="paragraph">
<p>References inherit rules from pointers and therefore refer to generic
address space objects by default (see <a href="#references"><em>References</em></a>) if
generic address space is supported, otherwise they refer to private
address space objects.</p>
</div>
<div class="paragraph">
<p>Class static data members are deduced to <code>__global</code> address space. Note,
that if the C++ for OpenCL 2021 implementation does not support program
scope variables (i.e. <code>__opencl_c_program_scope_global_variables</code> feature
from <code>OpenCL C 3.0 s6.1</code> is unsupported) the address space qualifier must be specified
explicitly and it must be the <code>__constant</code> address space.</p>
</div>
<div class="paragraph">
<p>All non-static member functions take an implicit object parameter <code>this</code>
that is a pointer type. By default the <code>this</code> pointer parameter is in the
generic address space if it is supported and in the private address space
otherwise. All concrete objects passed as an argument to the
implicit <code>this</code> parameter will be converted to this default (generic or private)
address space first if such conversion is valid. Therefore, when member functions
are called with objects created in disjoint address spaces from the default one,
the compilation must fail. To prevent the failure the address space on implicit
object parameter <code>this</code> must be specified using address space qualifiers
on member functions (see <a href="#addrspace-member-function-qualifiers"><em>Member function qualifier</em></a>). For example, use of member functions with
objects in <code>__constant</code> address space will always require a <code>__constant</code>
member function qualifier as <code>__constant</code> address space is disjoint with any
other.</p>
</div>
<div class="paragraph">
<p>Member function qualifiers can also be used in case address space conversions
are undesirable for example for performance reasons. For example, a method can
be implemented to exploit memory access coalescing for segments with memory bank.</p>
</div>
<div class="paragraph">
<p>Address spaces are not deduced for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>non-pointer/non-reference template parameters except for template
specializations or non-type based template parameters.</p>
</li>
<li>
<p>non-pointer/non-reference class members except for static data members
that are deduced to the <code>__global</code> address space for C++ for OpenCL 1.0
or C++ for OpenCL 2021 with the
<code>__opencl_c_program_scope_global_variables</code> feature.</p>
</li>
<li>
<p>non-pointer/non-reference type alias declarations.</p>
</li>
<li>
<p>decltype expressions.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">template &lt;typename T&gt;
void foo() {
  T m; // address space of 'm' will be known at template instantiation time.
  T * ptr; // 'ptr' points to generic address space object when it is
           // supported otherwise to __private address space.
  T &amp; ref = ...; // 'ref' references an object in generic address space when
                 // it is supported otherwise in __private address space.
};

template &lt;int N&gt;
struct S {
  int i; // 'i' has no address space.
  static int ii; // 'ii' is in global address space if program scope variables
                 // are supported; otherwise this statement is not legal.
  int * ptr; // 'ptr' points to int in generic address space if it is supported;
             // otherwise to __private address space.
  int &amp; ref = ...; // 'ref' references int in generic address space if it is
                   // supported; otherwise in __private address space.
};

template &lt;int N&gt;
void bar()
{
  S&lt;N&gt; s; // 's' is in __private address space.
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">struct c1 {};
using alias_c1 = c1; // 'alias_c1' is 'c1'.
using alias_c1_ptr = c1 *; // 'alias_c1_ptr' is a generic address space pointer to
                           // 'c1' when generic address space is supported; otherwise
                           // it points to 'c1' located in __private address space.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">__kernel void foo()
{
  __local int i;
  decltype(i)* ii; // type of 'ii' is '__local int *__private'.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the placeholder type specifier <code>auto</code> an address space of the outer type is
deduced as if it would be any other regular type. However if <code>auto</code> is used in a
reference or pointer type, the address space of a pointee is taken from the type
of the initialization expression. The logic follows rules for <code>const</code> and
<code>volatile</code> qualifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">// This example assumes that generic address space is supported.
__kernel void foo()
{
  __local int i;
  constexpr int c = 1;

  __constant auto cai = c; // type of 'cai' is '__constant int' (no deduction).

  auto aii = cai; // type of 'aii' is '__private int' (regular deduction).

  auto *ptr = &amp;i; // type of 'ptr' is '__local int * __private'
                  // (addr space of a pointer is deduced regularly,
                  // addr space of its pointee is taken from 'i').

  auto *&amp;refptr = ptr; // type of 'refptr' is '__local int * generic &amp; __private'
                       // (addr space of a reference and type of referencing object
                       // is deduced regularly,
                       // addr space of a pointee is taken from the pointee of 'ptr').
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="addrspace-member-function-qualifiers"><a class="anchor" href="#addrspace-member-function-qualifiers"></a>3.3.4. Member function qualifier</h4>
<div class="paragraph">
<p>C++ for OpenCL allows specifying an address space qualifier on member
functions to signal that they are to be used with objects constructed
in a specific address space. This works just the same as qualifying
member functions with <code>const</code> or any other qualifiers. The overloading
resolution will select the candidate with the most specific address
space if multiple candidates are provided. If there is no conversion
to an address space among candidates, compilation will fail with a
diagnostic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">struct C {
  C() __local {};
  C() __private {};
  constexpr C() __constant {};

  void foo() __local;
  void foo(); // This is implicitly qualified by generic address space
              // if it is supported otherwise by '__private'.
};

__kernel void bar() {
  __local C c1;      // will resolve to the first constructor overload.
  __private C c2;    // will resolve to the second constructor overload.
  __constant C c3{}; // will resolve to the third constructor overload.
  c1.foo(); // will resolve to the first 'foo'.
  c2.foo(); // will resolve to the second 'foo'.
  c3.foo(); // error due to mismatching address spaces - can't convert to
            // '__local' or generic/'__private' address spaces.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All member functions can be qualified by an address space qualifier including
constructors and destructors.</p>
</div>
</div>
<div class="sect3">
<h4 id="_lambda_function"><a class="anchor" href="#_lambda_function"></a>3.3.5. Lambda function</h4>
<div class="paragraph">
<p>The address space qualifier can be optionally added for lambda
expressions after the attributes. Similar to method qualifiers,
they will alter the default address space of lambda call operator
that has generic address space by default if it is supported otherwise
private address space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">__kernel void foo() {
  auto priv1 = []() __private {};
  priv1();
  auto priv2 = []() __global {};
  priv2(); // error: lambda object and its expression have mismatching address space.
  __constant auto const3 = []() __constant{};
  const3();

  [&amp;] () __global {} (); // error: lambda temporary is in __private address space.

  [&amp;] () mutable __private {} ();
  [&amp;] () __private mutable {} (); // error: mutable specifier should precede address
                                  // space.
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implicit_special_members"><a class="anchor" href="#_implicit_special_members"></a>3.3.6. Implicit special members</h4>
<div class="paragraph">
<p>The prototype for implicit special members (default, copy or move constructor,
copy or move assignment, destructor) has the default address space for an implicit
object pointer and reference parameters (see also
<a href="#addrspace-member-function-qualifiers"><em>Member function qualifier</em></a>). This default
address space is generic if it is supported or private otherwise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">class C {
  // Has the following implicitly defined member functions.

  // C(); /* implicit 'this' parameter is a pointer to */
          /* object in generic address space if supported, or */
          /* in private address space otherwise. */

  // C(const C &amp; par); /* 'this'/'par' is a pointer/reference to */
                       /*  object in generic address space */
                       /*  if supported, or */
                       /* in private address space otherwise. */

  // C(C &amp;&amp; par); /* 'this'/'par' is a pointer/r-val reference to */
                  /* object in generic address space if supported, or */
                  /* in private address space otherwise. */

  // C &amp; operator=(const C &amp; par); /* 'this'/'par'/return value is */
                                   /* a pointer/reference/reference to */
                                   /* object in generic address space */
                                   /* if supported, or */
                                   /* in private address space otherwise. */

  // C &amp; operator=(C &amp;&amp; par)'; /* 'this'/'par'/return value is */
                               /* a pointer/r-val reference/reference to */
                               /* object in generic address space, */
                               /* if supported, or */
                               /* in private address space otherwise. */
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_builtin_operators"><a class="anchor" href="#_builtin_operators"></a>3.3.7. Builtin operators</h4>
<div class="paragraph">
<p>All builtin operators are available with the specific address spaces, thus
no address space conversions (i.e. to generic address space) are performed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_templates"><a class="anchor" href="#_templates"></a>3.3.8. Templates</h4>
<div class="paragraph">
<p>There is no deduction of address spaces in non-pointer/non-reference
template parameters and dependent types (see <a href="#addrspace-deduction"><em>Address space inference</em></a>). The address space of a template parameter is deduced
during type deduction if it is not explicitly provided in the
instantiation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">1  template&lt;typename T&gt;
2  void foo(T* i){
3    T var;
4  }
5
6  __global int g;
7  void bar(){
8    foo(&amp;g); // error: template instantiation failed as function scope variable 'var'
9             // appears to be declared in __global address space (see line 3).
10 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not legal to specify multiple different address spaces between
template definition and instantiation. If multiple different address
spaces are specified in a template definition and instantiation,
compilation of such a program will fail with a diagnostic. This
restriction immediately follows from <code>OpenCL C 3.0 s6.7</code> that
disallows multiple address space qualifiers on a type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">template &lt;typename T&gt;
void foo() {
  __private T var;
}

void bar() {
  foo&lt;__global int&gt;(); // error: conflicting address space qualifiers are provided
                       // for 'var', '__global' and '__private'.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a template has been instantiated, regular restrictions for
address spaces will apply as described in <code>OpenCL C 3.0 s6.7</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">template&lt;typename T&gt;
void foo(){
  T var;
}

void bar(){
  foo&lt;__global int&gt;(); // error: function scope variable 'var' cannot be declared
                       // in '__global' address space.
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_temporary_materialization"><a class="anchor" href="#_temporary_materialization"></a>3.3.9. Temporary materialization</h4>
<div class="paragraph">
<p>All temporaries are materialized in <code>__private</code> address space. If a reference
with another address space is bound to them, a conversion will be generated
in case it is valid, otherwise compilation will fail with a diagnostic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">int bar(const unsigned int &amp;i); // references generic address space object
                                // if generic address space is supported
                                // otherwise private address space object.

void foo() {
  bar(1); // temporary is created in __private address space but (if generic
          // address space is supported) converted to generic address space
          // of parameter reference.
}

void f(__global float &amp;ref) {
  __global const int&amp; newref = ref; // error: address space mismatch between
                                    // temporary object created to hold value
                                    // converted float-&gt;int and local variable
                                    // (can't convert from __private to __global).
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_construction_initialization_and_destruction"><a class="anchor" href="#_construction_initialization_and_destruction"></a>3.3.10. Construction, initialization and destruction</h4>
<div class="paragraph">
<p>Construction, initialization and destruction of objects in <code>__private</code>
and <code>__global</code> address space follow the general principles of C++. For
program scope objects or static objects in the function scope with non-trivial
constructors and destructors, the implementation defines an ABI format for
runtime initialization and destruction of global objects before/after all
kernels are enqueued.</p>
</div>
<div class="paragraph">
<p>Objects in <code>__local</code> address space can not have initializers in
declarations and therefore a constructor can not be called. All objects
created in the local address space have undefined state at the point of
their declaration. Developers are free to define a special member function
that can initialize local address space objects after their declaration. Any
default values provided for the initialization of members in a class
declaration are ignored when creating the local address space objects. Since
the initialization is performed after the variable declaration, special handling
is required for classes with data members that are references because their values
can not be overwritten trivially. Destructors of local address space objects
are not invoked automatically. They can be called manually.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">class C {
  int m;
// If generic address space is not supported or for performance optimization
// purposes the following members might be required.
public:
  __local C &amp; operator=(const C &amp; par) __local;
  ~C() __local;
};
__kernel void foo() {
  __local C locobj{}; // error: local address space objects can't be initialized
  __local C locobj; // uninitialised object.
  locobj = {}; // calling copy assignment operator is allowed.
  locobj.~C(); // local address space object destructors are not invoked
               // automatically.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>User defined constructors in <code>__constant</code> address space must be <code>constexpr</code>.
Such objects can be initialized using literals and initialization lists if they
do not require any user defined conversions.</p>
</div>
<div class="paragraph">
<p>Objects in <code>__constant</code> address space can be initialized using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Literal expressions;</p>
</li>
<li>
<p>Uniform initialization syntax <code>{}</code>;</p>
</li>
<li>
<p>Using implicit constructors.</p>
</li>
<li>
<p>Using <code>constexpr</code> constructors.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">struct C1 {
  int m;
};

struct C2 {
  int m;
  constexpr C2(int init) __constant : m(init) {};
};

__constant C1 c1obj1 = {1};
__constant C1 c1obj2 = C1();
__constant C2 c2obj1(1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Non-trivial destructors for objects in non-default address spaces (i.e. all
other than generic address space when it is supported or <code>__private</code>
otherwise) are not required to be supported by implementations.
The macro <code>__opencl_cpp_destructor_with_address_spaces</code>,
which is defined if and only if such destructors are supported by an
implementation, can be used to check whether this functionality can be used
in kernel sources. Additionally destructors with global objects might not be
supported even if address spaces are supported with destructors in general.
Such functionality is indicated by the presence of the
<code>__opencl_cpp_global_destructor</code> macro. If the macro
<code>__opencl_cpp_global_destructor</code> is defined then
<code>__opencl_cpp_destructor_with_address_spaces</code> must also be defined.</p>
</div>
<div class="paragraph">
<p>Note that the destruction of objects in named address spaces <code>__global</code>,
<code>__local</code>, or <code>__private</code> can be performed using destructors with
default address space (i.e. generic) by utilising address space conversions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">1   // Example assumes generic address space support.
2   class C {
3   public:
4   #ifdef __opencl_cpp_destructor_with_address_spaces
5     ~C() __local;
6   #else
7     ~C();
8   #endif
9   };
10
11  kernel void foo() {
12    __local C locobj;
13    locobj.~C();    // uses destructor in local address space (on line 5)
14                    // if such destructors are supported,
15                    // otherwise uses generic address space destructor (on line 7)
16                    // converting to generic address prior to call into destructor.
17  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, when generic address space feature is unsupported, absence of
destructor support with address spaces results in a compilation failure
when such destructors overloaded with non-default address spaces are
encountered in the kernel code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">// Example assumes generic address space is not supported.
class C {
public:
  ~C();
};

kernel void foo() {
  __local C locobj;
  locobj.~C();    // error due to illegal conversion of 'this' from __local
                  // to __private address space pointer.
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_nested_pointers"><a class="anchor" href="#_nested_pointers"></a>3.3.11. Nested pointers</h4>
<div class="paragraph">
<p>C++ for OpenCL does not allow implicit address space conversions in nested
pointers even with compatible address spaces. The following rules apply
when converting between address spaces in nested pointers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implicit conversions of address spaces in nested pointers are disallowed.</p>
</li>
<li>
<p>Any address space conversion in nested pointers with safe casts (e.g.
<code>const_cast</code>, <code>static_cast</code>, <code>addrspace_cast</code>) is disallowed.</p>
</li>
<li>
<p>Any address space conversion in nested pointers can be done using low level
C-style or <code>reinterpret_cast</code>. No compatibility check is performed for
address spaces in nested pointers.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">local int * * locdefptr;
constant int * * cnstdefptr;
int * * defdefptr;
defdefptr = const_cast&lt;int * *&gt;(locdefptr); // illegal.
defdefptr = static_cast&lt;int * *&gt;(cnstdefptr); // illegal.
defdefptr = addrspace_cast&lt;int * *&gt;(cnstdefptr); // illegal.
defdefptr = reinterpret_cast&lt;int * *&gt;(locdefptr); // legal.
defdefptr = reinterpret_cast&lt;int * *&gt;(cnstdefptr); // legal.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remove-addrspace"><a class="anchor" href="#remove-addrspace"></a>3.3.12. Address space removal type trait</h4>
<div class="paragraph">
<p><code>template&lt;class T&gt; struct __remove_address_space;</code></p>
</div>
<div class="paragraph">
<p>C++ for OpenCL 2021 supports the type trait <code>__remove_address_space</code>
that provides the member <code>typedef type</code> which is the same as <code>T</code>, except
that its topmost address space qualifier is removed. Its effect is analogous
to <code>remove_const</code> and other similar type traits in C++17 <code>[meta.trans]</code>.
The trait only removes an address space qualifier from a given type, therefore,
all other type qualifiers such as <code>const</code> or <code>volatile</code> remain unchanged.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">template&lt;typename T&gt;
void foo(T *par) {
  T var1; // error: function scope variable cannot be declared in global
          // address space.
  __private T var2; // error: conflicting address space qualifiers are provided
                    // between types '__private T' and '__global int'.
  __private typename __remove_address_space&lt;T&gt;::type var3; // type of var3 is __private int.
}

void bar() {
  __global int* ptr;
  foo(ptr);
}</code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="cxxcasts"><a class="anchor" href="#cxxcasts"></a>3.4. C++ casts</h3>
<div class="paragraph">
<p>C++ has three cast operators in addition to C-style casts. Additional
logic specific to address spaces are applied to all casts as detailed in
<a href="#address_space_casts"><em>conversions with address spaces</em></a>.
<code>reinterpret_cast</code> has some additional functionality:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conversion between vectors and scalars are allowed.</p>
</li>
<li>
<p>Conversion between OpenCL types are disallowed.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_vectors_and_scalars"><a class="anchor" href="#_vectors_and_scalars"></a>3.4.1. Vectors and scalars</h4>
<div class="paragraph">
<p><code>reinterpret_cast</code> reinterprets between integral types like integers and
pointers. In C++ for openCL this also includes vector types, and so using
<code>reinterpret_cast</code> between vectors and scalars is also possible, as long as the
size of the vectors are the same.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">int i;
short2 s2 = reinterpret_cast&lt;short2&gt;(i); // legal.
int2 i2 = reinterpret_cast&lt;int2&gt;(i); // illegal.

short8 s8;
int4 i4 = reinterpret_cast&lt;int4&gt;(s8); // legal.
long l4 = reinterpret_cast&lt;long&gt;(s8); // illegal.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_opencl_types"><a class="anchor" href="#_opencl_types"></a>3.4.2. OpenCL types</h4>
<div class="paragraph">
<p>Some of the OpenCL-specific types, defined as "Other Built-in Data Types" in
<code>OpenCL C 3.0 s6.3.3</code>, are convertible to integer literals, but since they
are not conceptually integral, they can not be used with <code>reinterpret_cast</code>.
Therefore conversions of an OpenCL-specific type to any distinct type are
illegal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">queue_t q;
reserve_id_t id = reinterpret_cast&lt;reserve_id_t&gt;(q); // illegal.
int i = reinterpret_cast&lt;int&gt;(id); // illegal.</code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="kernel_function"><a class="anchor" href="#kernel_function"></a>3.5. Kernel functions</h3>
<div class="paragraph">
<p>Kernel functions have implicit C linkage (C++17 <code>[dcl.link]</code>) which
means that C++ specific features are not supported. Therefore, the kernel
functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can not be class members (C++17 <code>[class.mfct]</code>);</p>
</li>
<li>
<p>Can not be overloaded (C++17 <code>[over]</code>);</p>
</li>
<li>
<p>Can not be function templates (C++17 <code>[temp.fct]</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Moreover the types used in parameters of the kernel functions must be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Trivial and standard-layout types C++17 <code>[basic.types]</code> (plain old data
types) for parameters passed by value;</p>
</li>
<li>
<p>Standard-layout types for pointer parameters. The same applies to
references<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> if an implementation supports them in kernel
parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are additional restrictions to the list detailed in <code>OpenCL C 3.0 s6.11</code>.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_normative_references"><a class="anchor" href="#_normative_references"></a>4. Normative References</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="opencl-spec"></a> &#8220;The OpenCL Specification, Version 3.0&#8221;,
<a href="https://www.khronos.org/registry/OpenCL/" class="bare">https://www.khronos.org/registry/OpenCL/</a>.</p>
</li>
<li>
<p><a id="openclc-spec"></a> &#8220;The OpenCL C Specification, Version 3.0&#8221;,
<a href="https://www.khronos.org/registry/OpenCL/" class="bare">https://www.khronos.org/registry/OpenCL/</a>.</p>
</li>
<li>
<p><a id="cpp17-spec"></a> &#8220;ISO/IEC 14882:2017 - Programming languages  C++&#8221;,
<a href="https://www.iso.org/standard/68564.html" class="bare">https://www.iso.org/standard/68564.html</a>.
References are to sections of this specific version, referred to as the
&#8220;The C++17 Specification&#8221;, although other versions exist.</p>
</li>
<li>
<p><a id="embedded-c-spec"></a> &#8220;ISO/IEC TR 18037:2008 Programming languages -
C - Extensions to support embedded processors&#8221;,
<a href="https://www.iso.org/standard/51126.html" class="bare">https://www.iso.org/standard/51126.html</a>.
References are to sections of this specific version, referred to as the
&#8220;The Embedded C Specification&#8221;, although other versions exist.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<h2 id="acknowledgements" class="float">Acknowledgements</h2>
<div class="paragraph">
<p>The C++ for OpenCL documentation is the result of the contributions of
many people. Following is a partial list of the contributors, including
the company that they represented at the time of their contribution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Anastasia Stulova, Arm</p>
</li>
<li>
<p>Neil Hickey, Arm</p>
</li>
<li>
<p>Sven van Haastregt, Arm</p>
</li>
<li>
<p>Marco Antognini, Arm</p>
</li>
<li>
<p>Kevin Petit, Arm</p>
</li>
<li>
<p>Stuart Brady, Arm</p>
</li>
<li>
<p>Ole Strhm, Arm</p>
</li>
<li>
<p>Justas Janickas, Arm</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes" style="max-width: 100;">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. The macro belongs to the list of C++20&#8217;s feature test macros.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Whether C++ features (e.g references) can be used in functions with C linkage is implementation-defined (C++17 [dcl.link]).
</div>
</div>
<div id="footer" style="max-width: 100;">
<div id="footer-text">
Version DocRev2021.12<br>
Last updated 2022-12-01 18:28:40 UTC
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>